# Agile as Evolutionary Engineering Abstraction

Are Agile methodologies just another flavor of project management or an evolution of the science? Agile has distinct characteristics that are eerily similar to machine learning and can, in fact, historically be seen as the result of applying the rigorous methods and design patterns of software engineering to project management problems. 

1. Scrum as an Engineering Abstraction
1. A history
    
    1. It’s natural to plan and then execute a plan in stages. The bigger and more complex endeavor, the bigger and more complex the planning and execution. 
2. The reductionist model
    2. Engineering is about reductionism. When we speak of a lever and fulcrum, we don't think about the material those items are made of and if we do then we don’t think about the weather conditions surrounding them or the strength of the man wielding them. We abstract away details into separate domains of concern in order to get at what's important. Agile methods are an attempt to abstract away all the complex factors of project management. To identify the pivotal roles, functions, and artifacts of project management and create an irreducibly-complex model of the process. If you keep in mind that the latest industry-standard guide on project management is over 700 pages long, then you can appreciate the reductionism effort exemplified in the 20 page Scrum guide. 

            Please do not take me to mean that there is no value in classical PM training and thought. There is immense value. But...

3. Parallels with prevalent software engineering concepts
    3. The biggest parallel I see between waterfall and agile methods is what has happened in the realm of machine learning. The iterative method has won the day. We no longer seek to define objects or realities in Platonic absolutes but rather incrementally feed data to learning models and then ask them to predict. Over and over again. Until the models, taking into account, their previous learnings, are able to effectively predict the future. And, what’s more, as things change, so the models take in that account that change because they change with every iteration. 
    4. This iterative approach in combination with reducing the entire system down to a few entities gives us tractable complexity. 
2. Maximizing Returns
1. Amplifying engineering effectiveness
2. Insistence on irreducible complexity through naked scrum
3. Scaling through fractal application
4. Exhaustive quantification
5. Formalization
6. Distribution
7. Engineering culture

_[aka What happens when developers get a hold of project management.]_




Three roles: PO, ST, and SM. 

Four meetings: Planning, Standup, Review, and Retro. 

Two lists: PB and SB. 

An iterative engine: The sprint and the Increment. 

See: [The Scrum Guide](https://www.scrumguides.org/scrum-guide.html)